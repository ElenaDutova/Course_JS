"use strict";

/* Lesson 22. Copying Objects in JS */

/* Создадим объект и новую переменную, в которую поместим созданный объект: */

const obj = {
    a: 5,
    b: 6,
    c: {
        x: 10,
        y: 12
    }
};

// const copyObj = obj;

/* Попробуем изменить свойство a в объекте copyObj: */
// copyObj.a = 25;

/* Мы видим, что свойство поменялось не только в "копии" объекта,
но и в изначальном объекте: */
// console.log(obj);
// console.log(copyObj);

/* Это происходит потому, что оператор присваивания не создает копию объекта,
а только делает ОТСЫЛКУ к нему. 
То есть, присваивая переменной copyObj значение obj,
мы не копируем туда объект, хранящийся в obj,
а мы кладем туда ссылку на этот объект.
И таким образом, мы можем получить доступ к объекту,
как через obj, так и через copyObj. */

/* Все это может привести к ошибкам в коде. */

/* Мы можем попробовать перебрать объект циклом 
и записать каждое его значение в новый объект: */


function copy(mainObj) {
    let objCopy = {};
    for (let key in mainObj) {
        objCopy[key] = mainObj[key];
    }
    return objCopy;
}

const numbers = {
    a: 1,
    b: 4,
    c: {
        x: 10,
        y: 15
    }
};

const newNumbers = copy(numbers);

newNumbers.a = 100;
newNumbers.c.x = 0.888;

console.log(numbers);
console.log(newNumbers);

/* Однако, код выше копирует только перечисляемые свойства объекта numbers,
и если значением свойства окажется объект (как свойство "с" в нашем примере имеет значение объекта),
то свойство точно также будет ссылаться на оригинальный объект
и изменять его, как копией, так и оригинальным объектом. */

/* Важно помнить, что есть такие понятия как
ПОВЕРХНОСТНЫЕ и ГЛУБОКИЕ копии объектов.

При ПОВЕРХНОСТНОМ копировании копируются свойства, которые лежат на первом уровне,
но как только в каком-либо из свойств ориг-го объекта попадается объект,
он уже не копируется, а создается отсылка к нему 
в новом свойстве нового объекта.*/

/* Для создания повкерхностной копии помимо цикла мы можем использовать 
метод Object.assign(): */

const variables = {
    a: 28,
    b: 43,
    c: {
        x: 0.9,
        y: 0.75
    }
};

const add = {
    d: 17,
    e: 13
};

const newVariables = Object.assign(variables, add);

newVariables.d = 1117;

console.log(add);
console.log(newVariables);

/* ГЛУБОКАЯ копия объекта продублирует каждый объект на пути копирования.
Оригинал и скопированный объект не будут иметь ничего общего 
и совместно использоваться не будут.
Глубокое копирование будет разобрано далее по курсу. */

{ /* Копирование массива */

    /* Для копирования массива мы можем использовать метод slice(): */

    const oldArray = [1, 3, 5, [100, 99, 98], 9],
          newArray = oldArray.slice();

    newArray[2] = 555;
    newArray[3][1] = 101;

    console.log(oldArray);
    console.log(newArray);

    /* Метод создает поверхностную копию! */

}